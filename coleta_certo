const i2c = require('i2c-bus');
const amqp = require('amqplib');
const ping = require('ping');

const amqpServerUrl = 'amqp://W4nuCL2HK09PrG8H:7NXYX2gGYHGxCIBKoN3UtsLfRh@trends.injetoras.tcsapp.com.br:5672';
const amqpQueue = 'measurements';

const FILTRO = 0.03;
const LIMIAR_TENSAO = 28000;
const LIMIAR_CORRENTE = 28000;

const ID_TENSAO = 33;
const ID_CORRENTE = 32;

let isAMQPConnected = false;
let amqpChannelInfo = null;

const buffer = Buffer.alloc(9); // Buffer para armazenar os dados recebidos

const i2cBus = i2c.openSync(1); // Abre o barramento I2C (pode ser 1 ou 0 dependendo do Raspberry Pi)

const measurementData = {
  tensaoAnterior: 0,
  correnteAnterior: 0,
};

i2cBus.readI2cBlock(8, buffer.length, buffer, (err, bytesRead, buffer) => {
  if (err) {
    console.error('Erro na leitura I2C:', err);
    return;
  }

  const tipo = String.fromCharCode(buffer[0]);

  // Verifica o tipo e faz a leitura adequada
  if (tipo === 'T' || tipo === 'C') {
    const valor = buffer.readFloatLE(1);

    if (!isNaN(valor)) {
      if (tipo === 'T') {
        measurementData.tensaoAnterior = valor;
      } else {
        measurementData.correnteAnterior = valor;
      }

      console.log('Tipo:', tipo, 'Valor:', valor);

      // Enviar os dados para o servidor AMQP
      const timestamp = Date.now();
      sendToAMQP(tipo === 'T' ? ID_TENSAO : ID_CORRENTE, valor, timestamp);
    } else {
      console.error('Valor lido do I2C é inválido.');
    }
  } else {
    console.error('Tipo desconhecido recebido:', tipo);
  }
});
