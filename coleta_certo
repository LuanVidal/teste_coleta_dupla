const i2c = require('i2c-bus');
const amqp = require('amqplib');

const amqpServerUrl = 'amqp://W4nuCL2HK09PrG8H:7NXYX2gGYHGxCIBKoN3UtsLfRh@trends.injetoras.tcsapp.com.br:5672';
const amqpQueue = 'measurements';

const FILTRO = 0.03;
const LIMIAR_TENSAO = 28000;
const LIMIAR_CORRENTE = 28000;

const ID_TENSAO = 33;
const ID_CORRENTE = 32;

let isAMQPConnected = false;
let amqpChannelInfo = null;

const buffer = [];

const i2cBus = i2c.openSync(1); // Abre o barramento I2C (pode ser 1 ou 0 dependendo do Raspberry Pi)

const measurementData = {
  tensaoAnterior: 0,
  correnteAnterior: 0,
};

i2cBus.readI2cBlock(8, 9, 9, Buffer.alloc(9), (err, bytesRead, buffer) => {
  if (err) {
    console.error('Erro na leitura I2C:', err);
    return;
  }

  const tipo = String.fromCharCode(buffer[0]);
  const tensao = buffer.readFloatLE(1);
  const corrente = buffer.readFloatLE(5);

  if (!isNaN(tensao) && !isNaN(corrente)) {
    measurementData.tensaoAnterior = parseFloat(tensao.toFixed(2));
    measurementData.correnteAnterior = parseFloat(corrente.toFixed(2));

    console.log('Tipo:', tipo, 'Tensão:', tensao, 'Corrente:', corrente);

    // Enviar os dados para o servidor AMQP
    const timestamp = Date.now();
    sendToAMQP(ID_TENSAO, measurementData.tensaoAnterior, timestamp);
    sendToAMQP(ID_CORRENTE, measurementData.correnteAnterior, timestamp);
  } else {
    console.error('Valores lidos do I2C são inválidos.');
  }
});
