const i2c = require('i2c-bus');
const amqp = require('amqplib');
const ping = require('ping');

const amqpServerUrl = 'amqp://W4nuCL2HK09PrG8H:7NXYX2gGYHGxCIBKoN3UtsLfRh@trends.injetoras.tcsapp.com.br:5672';
const amqpQueue = 'measurements';

const FILTRO = 0.03;
const LIMIAR_TENSAO = 28000;
const LIMIAR_CORRENTE = 28000;

const ID_TENSAO = 33;
const ID_CORRENTE = 32;

let isAMQPConnected = false;
let amqpChannelInfo = null;

const i2cBus = i2c.openSync(1); // Abre o barramento I2C (pode ser 1 ou 0 dependendo do Raspberry Pi)

const measurementData = {
  tensaoAnterior: 0,
  correnteAnterior: 0,
};

function readI2CData() {
  // Ler os dados I2C um byte por vez
  const tipo = String.fromCharCode(i2cBus.readByteSync(8));
  const tensaoBuffer = Buffer.alloc(4);
  i2cBus.readI2cBlockSync(8, 1, 4, tensaoBuffer);
  const tensao = tensaoBuffer.readFloatLE(0);

  const correnteBuffer = Buffer.alloc(4);
  i2cBus.readI2cBlockSync(8, 5, 4, correnteBuffer);
  const corrente = correnteBuffer.readFloatLE(0);

  if (!isNaN(tensao) && !isNaN(corrente)) {
    measurementData.tensaoAnterior = tensao;
    measurementData.correnteAnterior = corrente;

    console.log('Tipo:', tipo, 'Tensão:', tensao, 'Corrente:', corrente);

    // Enviar os dados para o servidor AMQP
    const timestamp = Date.now();
    sendToAMQP(ID_TENSAO, tensao, timestamp);
    sendToAMQP(ID_CORRENTE, corrente, timestamp);
  } else {
    console.error('Valores lidos do I2C são inválidos.');
  }
}

setInterval(readI2CData, 200);
